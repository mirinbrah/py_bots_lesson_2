# --- 1 - Список [List] ---
# Это основной и самый гибкий тип коллекций.
# Упорядоченный, Изменяемый, допускает дубликаты.
# Стоит использовать по умолчанию, если нет специальной задачи.
fruits_list = ["яблоко", "банан", "банан", "вишня"]

# --- 2 - Кортеж (tuple) ---
# Основная особенность - неизменяемый.
# Упорядоченный, Неизменяемый, допускает дубликаты.
# Стоит использовать для данных, которые не должны меняться (дни недели, координаты).
fruits_tuple = ("яблоко", "банан", "банан", "вишня")

# --- 3 - Словарь {dict key:value} ---
# Основная особенность - доступ по уникальному ключу.
# Упорядоченный (с python 3.7), Изменяемый.
# Ключи уникальные, значения могут повторяться.
# Стоит использовать для структурированных данных (анкета пользователя, настройки).
user = {
    "name": "Петя",
    "age": 23,
    "city": "Москва",
    "is_student": False
}

# --- 4 - Множество {set} ---
# Основная особенность - хранит только уникальные элементы, не упорядочен.
# Изменяемый, Неупорядоченный, НЕ допускает дубликаты.
# Стоит использовать для быстрой проверки на наличие элемента и удаления дублей.
list_with_duplicates = [1, 5, 2, 8, 5, 1, 9, 2]
set_unique_numbers = set(list_with_duplicates)


# --- Демонстрация ---

def demonstrate_lists():
    print("------ 1. РАБОТА СО СПИСКАМИ (LIST) ------")
    my_list = ["яблоко", "банан", "вишня"]
    print(f"Исходный список: {my_list}")

    # .append() - добавить в конец
    my_list.append("апельсин")
    print(f"После .append('апельсин'): {my_list}")

    # .insert() - вставить по индексу
    my_list.insert(1, "манго")
    print(f"После .insert(1, 'манго'): {my_list}")

    # .remove() - удалить по значению (первое вхождение)
    my_list.remove("банан")
    print(f"После .remove('банан'): {my_list}")

    # .pop() - удалить по индексу (и вернуть значение)
    last_item = my_list.pop()
    print(f"После .pop() (удалили '{last_item}'): {my_list}")

    # len() - получить длину
    print(f"Длина списка: {len(my_list)}")

    # .sort() - сортировка на месте
    my_list.sort()
    print(f"После .sort(): {my_list}")
    print("-" * 20)


def demonstrate_tuples():
    print("------ 2. РАБОТА С КОРТЕЖАМИ (TUPLE) ------")
    my_tuple = ("яблоко", "банан", "вишня", "банан")
    print(f"Исходный кортеж: {my_tuple}")

    # Доступ по индексу (как у списка)
    print(f"Элемент с индексом 0: {my_tuple[0]}")

    # .count() - посчитать количество вхождений
    banana_count = my_tuple.count("банан")
    print(f"Количество бананов: {banana_count}")

    # .index() - найти индекс первого вхождения
    cherry_index = my_tuple.index("вишня")
    print(f"Индекс вишни: {cherry_index}")

    # Попытка изменить кортеж вызовет ошибку TypeError, поэтому мы ее "ловим"
    try:
        my_tuple[0] = "манго"
    except TypeError as e:
        print(f"Попытка изменить кортеж вызывает ошибку: {e}")
    print("-" * 20)


def demonstrate_dicts():
    print("------ 3. РАБОТА СО СЛОВАРЯМИ (DICT) ------")
    my_dict = {
        "name": "Петя",
        "age": 23,
        "is_student": False
    }
    print(f"Исходный словарь: {my_dict}")

    # Получение значения по ключу
    print(f"Значение по ключу 'name': {my_dict['name']}")

    # .get() - безопасное получение значения (вернет None, если ключа нет)
    print(f"Безопасное получение 'city': {my_dict.get('city', 'Не указан')}")

    # Добавление/изменение элемента
    my_dict["city"] = "Санкт-Петербург"
    print(f"После добавления/изменения города: {my_dict}")

    # .pop() - удалить по ключу (и вернуть значение)
    is_student_status = my_dict.pop("is_student")
    print(f"После .pop('is_student') (удалили '{is_student_status}'): {my_dict}")

    # .keys(), .values(), .items() - для перебора
    print(f"Все ключи: {list(my_dict.keys())}")
    print(f"Все значения: {list(my_dict.values())}")
    print("-" * 20)


def demonstrate_sets():
    print("------ 4. РАБОТА С МНОЖЕСТВАМИ (SET) ------")
    my_set = {"яблоко", "банан", "вишня"}
    print(f"Исходное множество: {my_set}")

    # .add() - добавить элемент (дубликат будет проигнорирован)
    my_set.add("апельсин")
    my_set.add("яблоко")  # Эта строка ничего не изменит
    print(f"После .add(): {my_set}")

    # .remove() - удалить элемент (вызовет ошибку, если элемента нет)
    my_set.remove("банан")
    print(f"После .remove('банан'): {my_set}")

    # .discard() - безопасное удаление (ошибки не будет, если элемента нет)
    my_set.discard("манго")
    print(f"После .discard('манго'): {my_set}")

    # Операции с другим множеством
    other_set = {"вишня", "манго"}
    # .intersection() - пересечение (общие элементы)
    print(f"Пересечение с {other_set}: {my_set.intersection(other_set)}")
    # .union() - объединение (все элементы)
    print(f"Объединение с {other_set}: {my_set.union(other_set)}")
    print("-" * 20)


def main():
    demonstrate_lists()
    demonstrate_tuples()
    demonstrate_dicts()
    demonstrate_sets()


if __name__ == "__main__":
    main()